# 1.中断

## 启动
DISK（硬盘上存放os）
BIOS（基本I/O处理系统，开机后检查外设，加载相应软件执行）
Bootoader: 存在DISK，用来加载OS，让OS从硬盘放到内存里，让CPU可以执行操作系统

BIOS 从特定地址开始读 (X86 CS:IP = 0xf000:fff0 CS段寄存器 IP指令寄存器) 
加电自检  寻找显卡和执行BIOS  BIOS把bootloader从硬盘放到内存

bootloader 放到硬盘第一个主引导扇区（一般512字节）
bootloader找到硬盘的起始扇区以及硬盘的操作系统的起始扇区和操作系统长度，把这一块区域可能包含几个硬盘的磁盘块，把这个磁盘块读到内存中去
把CPU控制权交给os，到os起始位置执行

## 操作系统与设备和程序交互
操作系统的interface设计  
面向外设是通过中断和I/O来处理  
面向应用程序是通过系统调用和异常来提供一些相应功能

## 中断，异常和系统调用
1. 系统调用  应用程序 向操作系统发出服务请求 异步或同步  
2. 异常  不良的应用程序 非法指令或其他坏的处理状态如：内存出错 同步  
3. 中断  外设 来自不同的硬件设备的计时器和网络的中断 异步  

同步、异步  
异步：当事件产生，应用程序并不知道什么时候产生，（这里中断是不受控制的，所以异步，同一时间点执行很多事情）  
异常：执行除零指令一定会发生，同步  
系统调用：发出请求的点同步，返回点 返回的过程有可能同步有可能异步

响应  
中断：持续，对用户应用程序透明（用户感受不到中断）  
异常：杀死或重新执行 意想不到的应用程序指令  
系统调用：等待和持续（等待服务完成继续执行)

## 中断和异常处理机制
1. 中断  
查中断表（中断号-》对应地址 针对对应中断的服务例程的地址）  
硬件：设置中断标记（CPU看到那个标记，产生中断号，发给操作系统）  
软件：保存当前处理状态 中断服务程序处理（根据中断号查到对应中断内存地址跳到这执行） 清除中断标记 恢复之前保存的处理状态（数据 寄存器）

2. 异常 CPU得到异常编号  
保存现场 异常处理：杀死产生异常的程序或重新执行异常指令  恢复现象重新执行

3. 系统调用  
如：应用程序printf(),会触发系统调用write()  
write带了一些参数，让那个设备来显示字符串以及字符串的内容   
操作系统获取参数后，会直接访问对应的设备 比如屏幕 返回成功或失败 应用程序进行后续工作

对于其他系统调用而言，也是大致同样的处理过程，只是完成的具体内容不同
有通用的系统调用接口，有了这层接口之后，应用程序就可以完成各种各样的功能，来对计算机进行间接的控制和管理
程序访问主要是通过高层次的API接口而不是直接进行系统调用

Win32 API用于Windows，  POSIX API用于POSIX-based systems（包括UNIX，LINUX，Mac OS X的所有版本）， Java API用于JAVA虚拟机（JVM）

## 怎么实现系统调用
1. **用户态 内核态**  
用户态：应用程序执行过程中，CPU处于的一个特权级的状态，它的特权级特别低，不能访问某些特殊的机器指令和不能直接访问I/O  
内核态：操作系统运行过程中，CPU所处于的一个状态，在这个状态下，操作系统可以执行CPU提供任何一条指令，包括特权指令，访问I/O指令，使得安全性得到保障


操作系统可以对应用程序发出这些系统调用的参数（系统调用的这些ID号作出一个标识）使得来对这个系统调用作出一个识别，然后完成具体的服务，这是它的一个处理过程
 

2. **系统调用和函数调用区别**  
函数调用：应用程序发出函数调用，是在一个栈空间完成函数之间一个参数传递和参数返回  
系统调用：应用程序和内核（操作系统）实际上拥有各自的堆栈。就意味着当应用程序发出系统调用之后，当它切换到内核里面执行的时候，需要切换堆栈，同时还需要完成特权级的转换（用户态到内核态的转换）。内核的转换和堆栈的转换都需要一定的开销。就意味着当执行一个系统调用时比执行函数调用时开销大得多。回报就是安全可靠

## 跨越操作系统边界的开销
**（中断 异常 系统调用的开销）**  
1. 建立中断，异常，系统调用号 对应服务例程 映射关系的初始化开销
2. 建立内核堆栈  
（操作系统它有自己的堆栈，不能和应用程序的堆栈混为一谈）维护堆栈的开销（操作系统退出时要把堆栈保存，操作系统执行时要把堆栈恢复。同理退出应用程序的执行到内核里面来执行时，把应用程序堆栈做一个保存，最后做恢复的处理过程。）
3. 验证参数  
（操作系统不信任应用程序，可能会有恶意程序）这个检查也是需要一定的时间开销的
内核态映射到用户态的地址空间 更新页面映射权限（操作系统处理完某些数据，需要把这些数据从内核态导到用户态，导的过程实际是个拷贝的过程，内存拷贝会引入新的开销。不能像应用程序在执行过程中简单用指针传递来实现。必须把内存空间的数据从内核空间拷到用户空间。）
4. 内核态独立地址空间 TLB  
（随着应用程序执行，有可能会引起内存的一个状态的改变，页机制的一个转变 Catch Tob， 关于CPU的catch和tob有可能会刷新，这些刷新过程有可能导致额外的开销） 
--- 
 ~~20190130~~

